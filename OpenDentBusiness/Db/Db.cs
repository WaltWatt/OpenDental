using System;
using System.Collections.Generic;
using System.Data;
using System.Reflection;
using System.Text;
using CodeBase;

namespace OpenDentBusiness {
	///<summary>Used to send queries. The methods are internal since it is not acceptable for the UI to be sending queries.</summary>
	public class Db {

		///<summary>A thread safe and thread specific value containing the last SQL command attempted.</summary>
		[ThreadStatic]
		private static string _lastCommand="[COMMAND NOT SET]";

		///<summary>The last SQL command attempted.</summary>
		public static string LastCommand {
			get	{
				return _lastCommand;
			}
		}

		///<summary>This is true if a connection to the database has been established.</summary>
		public static bool HasDatabaseConnection {
			get {
				return !string.IsNullOrEmpty(DataConnection.GetServerName()) || !string.IsNullOrEmpty(DataConnection.GetConnectionString());
			}
		}

		///<summary>Returns true if mysql variable "AUTO_INCREMENT_OFFSET" equals 1, otherwise false.</summary>
		public static bool IsAutoIncrementOffsetSetForReplication() {
			if(GetAutoIncrementOffset().In(1,-1)) {//auto_increment_offset is default value or not found (not found shouldn't happen, but for safety's sake).
				return false;
			}
			return true;
		}

		/// <summary>Returns mysql variable "AUTO_INCREMENT_OFFSET", or -1 if variable not found.</summary>
		public static int GetAutoIncrementOffset() {
			string command="SHOW VARIABLES LIKE 'auto_increment_offset'";
			DataTable table=GetTable(command);
			if(table.Rows.Count>0) {
				foreach(DataRow row in table.Rows) {
					if((string)row["Variable_name"]=="auto_increment_offset") {
						return PIn.Int((string)table.Rows[0]["Value"]);
					}
				}
			}
			return -1;//auto_increment_offset variable not found, just in case.
		}

		///<summary></summary>
		internal static DataTable GetTable(string command) {
			DataTable retVal=GetTableWithRemotingRoleCheck(command);
			retVal.TableName="";//this is needed for FormQuery dataGrid
			return retVal;
		}

		///<summary>Performs PIn.Long on first column of table returned. Surround with try/catch. Returns empty list if nothing found.</summary>
		internal static List<long> GetListLong(string command) {
			List<long> retVal=new List<long>();
			DataTable Table=GetTableWithRemotingRoleCheck(command);
			for(int i=0;i<Table.Rows.Count;i++) {
				retVal.Add(PIn.Long(Table.Rows[i][0].ToString()));
			}
			return retVal;
		}

		///<summary>Performs PIn.String on first column of table returned. Returns empty list if nothing found.</summary>
		internal static List<string> GetListString(string command) {
			List<string> retVal=new List<string>();
			DataTable Table=GetTableWithRemotingRoleCheck(command);
			for(int i=0;i<Table.Rows.Count;i++) {
				retVal.Add(PIn.String(Table.Rows[i][0].ToString()));
			}
			return retVal;
		}

		///<summary>Gets the table after checking remoting role.</summary>
		private static DataTable GetTableWithRemotingRoleCheck(string command) {
			_lastCommand=command;
			if(RemotingClient.RemotingRole==RemotingRole.ClientWeb) {
				if(RemotingClient.IsReportServer) {
					return Reports.GetTable(command);
				}
				throw new ApplicationException("No longer allowed to send sql directly.  For user sql, use GetTableLow.  Othewise, rewrite the calling "
					+"class to not use this query:\r\n"+command);
			}
			return DataCore.GetTable(command);
		}

		///<summary>This is used for queries written by the user.  If using direct connection, it gets a table in the ordinary way.  If ServerWeb, it uses the user with lower privileges to prevent injection attack.</summary>
		internal static DataTable GetTableLow(string command) {
			_lastCommand=command;
			DataTable retVal;
			if(RemotingClient.RemotingRole==RemotingRole.ClientWeb) {
				throw new ApplicationException("Rewrite the calling class to pass this query off to the server:\r\n"+command);
			}
			else if(RemotingClient.RemotingRole==RemotingRole.ClientDirect) {
				retVal=DataCore.GetTable(command);
			}
			else {//ServerWeb
				retVal=DataCore.GetTableLow(command);
			}
			retVal.TableName="";//this is needed for FormQuery dataGrid
			return retVal;
		}

		/*
		///<summary>This is for multiple queries all concatenated together with ;</summary>
		internal static DataSet GetDataSet(string commands) {
			if(RemotingClient.RemotingRole==RemotingRole.ClientWeb) {
				throw new ApplicationException("No longer allowed to send sql directly.  Rewrite the calling class to not use this query:\r\n"+commands);
			}
			else {
				return DataCore.GetDataSet(commands);
			}
		}*/

		///<summary>This query is run with full privileges.  This is for commands generated by the main program, and the user will not have access for injection attacks.  Result is usually number of rows changed, or can be insert id if requested.  WILL NOT RETURN CORRECT PRIMARY KEY if the query specifies the primary key.</summary>
		internal static long NonQ(string command,bool getInsertID,string columnNamePK,string tableName,params OdSqlParameter[] parameters) {
			_lastCommand=command;
			if(RemotingClient.RemotingRole==RemotingRole.ClientWeb) {
				throw new ApplicationException("No longer allowed to send sql directly.  Rewrite the calling class to not use this query:\r\n"+command);
			}
			else {
				return DataCore.NonQ(command,getInsertID,columnNamePK,tableName,parameters);
			}
		}

		///<summary>This query is run with full privileges.  This is for commands generated by the main program, and the user will not have access for injection attacks.  Result is usually number of rows changed, or can be insert id if requested.  WILL NOT RETURN CORRECT PRIMARY KEY if the query specifies the primary key.</summary>
		internal static long NonQ(string command,bool getInsertID,params OdSqlParameter[] parameters) {
			if(getInsertID && DataConnection.DBtype==DatabaseType.Oracle) {
				//The engineer that called this method needs to call the one that accepts a columnNamePK and tableName in order to get the Insert ID back.
				throw new ApplicationException("This overload of Db.NonQ is not Oracle compatible for getting the last insert ID.");
			}
			//MySQL is smart enough to know what the last insert ID was so let it go through without passing in a columnNamePK and tableName.
			return NonQ(command,getInsertID,"","",parameters);
		}

		///<summary>This query is run with full privileges.  This is for commands generated by the main program, and the user will not have access for injection attacks.  Result is usually number of rows changed, or can be insert id if requested.</summary>
		internal static long NonQ(string command,params OdSqlParameter[] parameters) {
			return NonQ(command,false,parameters);
		}

		///<summary>We need to get away from this due to poor support from databases.  For now, each command will be sent entirely separately.  This never returns number of rows affected.</summary>
		internal static long NonQ(string[] commands) {
			if(RemotingClient.RemotingRole==RemotingRole.ClientWeb) {
				throw new ApplicationException("No longer allowed to send sql directly.  Rewrite the calling class to not use this query:\r\n"+commands[0]);
			}
			for(int i=0;i<commands.Length;i++) {
				_lastCommand=commands[i];
				DataCore.NonQ(commands[i],false);
			}
			return 0;
		}

		///<summary>This is used only for historical commands in ConvertDatabase.   WILL NOT RETURN CORRECT PRIMARY KEY if the query specifies the primary key.</summary>
		internal static int NonQ32(string command,bool getInsertID) {
			_lastCommand=command;
			if(RemotingClient.RemotingRole==RemotingRole.ClientWeb) {
				throw new ApplicationException("No longer allowed to send sql directly.  Rewrite the calling class to not use this query:\r\n"+command);
			}
			else {
				return (int)DataCore.NonQ(command,getInsertID);
			}
		}

		///<summary>This is used for historical commands in ConvertDatabase.  Seems to also be used in DBmaint when counting rows affected.</summary>
		internal static int NonQ32(string command) {
			return NonQ32(command,false);
		}

		///<summary>This is used only for historical commands in ConvertDatabase.</summary>
		internal static int NonQ32(string[] commands) {
			if(RemotingClient.RemotingRole==RemotingRole.ClientWeb) {
				throw new ApplicationException("No longer allowed to send sql directly.  Rewrite the calling class to not use this query:\r\n"+commands[0]);
			}
			for(int i=0;i<commands.Length;i++) {
				_lastCommand=commands[i];
				DataCore.NonQ(commands[i],false);
			}
			return 0;
		}

		///<summary>We use this for queries that return a single value that is an int.  If there are no results, it will return 0.</summary>
		internal static int GetInt(string command) {
			return PIn.Int((GetLong(command).ToString()),false);
		}

		///<summary>We use this for queries that return a single value that is a long.  If there are no results, it will return 0.</summary>
		internal static long GetLong(string command) {
			_lastCommand=command;
			if(RemotingClient.RemotingRole==RemotingRole.ClientWeb) {
				throw new ApplicationException("No longer allowed to send sql directly.  Rewrite the calling class to not use this query:\r\n"+command);
			}
			else {
				DataTable table=DataCore.GetTable(command);
				if(table.Rows.Count==0) {
					return 0;
				}
				return PIn.Long(table.Rows[0][0].ToString());
			}
		}

		///<summary>Use this for count(*) queries.  They are always guaranteed to return one and only one value.  Not any faster, just handier.  Can also be used when retrieving prefs manually, since they will also return exactly one value.</summary>
		internal static string GetCount(string command) {
			_lastCommand=command;
			if(RemotingClient.RemotingRole==RemotingRole.ClientWeb) {
				throw new ApplicationException("No longer allowed to send sql directly.  Rewrite the calling class to not use this query:\r\n"+command);
			}
			else {
				return DataCore.GetTable(command).Rows[0][0].ToString();
			}
		}

		///<summary>Use this only for queries that return one value.</summary>
		internal static string GetScalar(string command) {
			_lastCommand=command;
			if(RemotingClient.RemotingRole==RemotingRole.ClientWeb) {
				throw new ApplicationException("No longer allowed to send sql directly.  Rewrite the calling class to not use this query:\r\n"+command);
			}
			else {
				return DataCore.GetScalar(command);
			}
		}

		#region old
		///<summary>Always throws exception.</summary>
		public static DataTable GetTableOld(string command) {
			throw new ApplicationException("No queries allowed in the UI layer.");
		}

		///<summary>Always throws exception.</summary>
		public static int NonQOld(string[] commands) {
			throw new ApplicationException("No queries allowed in the UI layer.");
		}

		///<summary>Always throws exception.</summary>
		public static int NonQOld(string command) {
			throw new ApplicationException("No queries allowed in the UI layer.");
		}
		#endregion old


	}
}
